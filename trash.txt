#!/bin/bash

# Funkcja do konfiguracji Gita
setup_git() {
    # Dekodowanie Base64
    REPO_OWNER=$(echo "$BASE64_REPO_OWNER" | base64 --decode)
    REPO_NAME=$(echo "$BASE64_REPO_NAME" | base64 --decode)
    FILE_PATH=$(echo "$BASE64_FILE_PATH" | base64 --decode)
    BRANCH_NAME=$(echo "$BASE64_BRANCH_NAME" | base64 --decode)
    TOKEN=$(echo "$BASE64_TOKEN" | base64 --decode)

    # Sprawdzanie, czy Git jest skonfigurowany
    if ! git config --global user.name &>/dev/null || ! git config --global user.email &>/dev/null; then
        echo "Git nie jest skonfigurowany, konfiguruje Git z tokenem..."
        # Ustawienie konfiguracji Git
        git config --global user.name "$REPO_OWNER"
        git config --global user.email "$REPO_OWNER@github.com"

        # Ustawienie tokena do autentykacji GitHub
        git config --global credential.helper store
        echo "https://$TOKEN@github.com" > ~/.git-credentials
    else
        echo "Git jest już skonfigurowany."
    fi

    # Ustawienie strategii dla pull (merge)
    git config --global pull.rebase false  # merge (domyślna strategia)
    echo "Ustawiono strategię pull.rebase na 'false' (merge)."
}

# Funkcja do dekodowania Base64 i wysyłania danych
decode_and_upload() {
    # Dekodowanie Base64
    REPO_OWNER=$(echo "$BASE64_REPO_OWNER" | base64 --decode)
    REPO_NAME=$(echo "$BASE64_REPO_NAME" | base64 --decode)
    FILE_PATH=$(echo "$BASE64_FILE_PATH" | base64 --decode)
    BRANCH_NAME=$(echo "$BASE64_BRANCH_NAME" | base64 --decode)
    TOKEN=$(echo "$BASE64_TOKEN" | base64 --decode)

    # Logowanie wartości BRANCH_NAME
    echo "Gałąź BRANCH_NAME: $BRANCH_NAME"

    # Pobranie treści ze schowka
    text=$(xclip -o -selection clipboard)

    # Logowanie treści schowka
    echo "Treść schowka: $text"

    # Jeśli treść schowka jest pusta
    if [ -z "$text" ]; then
        echo "Schowek jest pusty."
        notify-send "GitClip" "Schowek jest pusty. Nie wysłano żadnych danych."
        exit 1
    fi

    # Tworzenie tymczasowego repozytorium w /tmp
    TMP_DIR=$(mktemp -d /tmp/gitclip_repo.XXXXXX)
    echo "Tworzę tymczasowe repozytorium w $TMP_DIR"
    
    # Inicjalizacja repozytorium
    cd "$TMP_DIR" || exit 1
    git init
    git remote add origin "https://$TOKEN@github.com/$REPO_OWNER/$REPO_NAME.git"
    
    # Sprawdzanie, czy gałąź "main" istnieje
    if ! git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        echo "Gałąź $BRANCH_NAME nie istnieje. Tworzę ją..."
        git checkout -b "$BRANCH_NAME"
    else
        git checkout "$BRANCH_NAME"
    fi

    # Tworzenie pliku z treścią schowka
    TMP_FILE="$TMP_DIR/$(basename "$FILE_PATH")"
    echo -n "$text" > "$TMP_FILE"

    # Logowanie zawartości pliku przed dodaniem do repozytorium
    echo "Zawartość pliku przed dodaniem:"
    cat "$TMP_FILE"

    # Dodanie pliku do repozytorium
    git add "$TMP_FILE"
    git commit -m "Upload tekstu z schowka"

    # Pobranie zmian z zdalnego repozytorium, zezwalając na łączenie niezwiązanych historii
    git fetch origin "$BRANCH_NAME" || { echo "Błąd przy pobieraniu zmian z zdalnego repozytorium."; exit 1; }
    
    # Zignorowanie konfliktu i nadpisanie pliku z zawartości schowka
    git pull origin "$BRANCH_NAME" --allow-unrelated-histories --no-edit || {
        echo "Błąd przy łączeniu zmian, nadpisuję konflikt.";
        git checkout --theirs "$TMP_FILE" # Nadpisanie pliku lokalnym (ze schowka) wersją z repozytorium
        git add "$TMP_FILE"
        git commit -m "Naprawa konfliktu: Nadpisanie pliku."
    }

    # Push na GitHub
    git push origin "$BRANCH_NAME" || { echo "Błąd przy wysyłaniu do repozytorium."; exit 1; }
    echo "Treść schowka została przesłana!"

    # Skopiowanie URL do wersji raw
    RAW_URL="https://raw.githubusercontent.com/$REPO_OWNER/$REPO_NAME/$BRANCH_NAME/$(basename "$FILE_PATH")"
    echo "Link do wersji raw: $RAW_URL"
    
    # Skopiowanie URL do schowka
    echo -n "$RAW_URL" | xclip -selection clipboard
    
    # Powiadomienie o sukcesie
    notify-send "GitClip" "Treść schowka została wysłana na GitHub! Link do pliku w wersji raw skopiowany do schowka."

    # Usuwanie tymczasowego repozytorium
    rm -rf "$TMP_DIR"
    echo "Tymczasowe repozytorium zostało usunięte."
}

# Funkcja do czyszczenia pliku (wysyła pustą wiadomość)
clear_file() {
    # Dekodowanie Base64
    REPO_OWNER=$(echo "$BASE64_REPO_OWNER" | base64 --decode)
    REPO_NAME=$(echo "$BASE64_REPO_NAME" | base64 --decode)
    FILE_PATH=$(echo "$BASE64_FILE_PATH" | base64 --decode)
    BRANCH_NAME=$(echo "$BASE64_BRANCH_NAME" | base64 --decode)
    TOKEN=$(echo "$BASE64_TOKEN" | base64 --decode)

    # Tworzenie tymczasowego repozytorium w /tmp
    TMP_DIR=$(mktemp -d /tmp/gitclip_repo.XXXXXX)
    echo "Tworzę tymczasowe repozytorium w $TMP_DIR"
    
    # Inicjalizacja repozytorium
    cd "$TMP_DIR" || exit 1
    git init
    git remote add origin "https://$TOKEN@github.com/$REPO_OWNER/$REPO_NAME.git"
    
    # Sprawdzanie, czy gałąź "main" istnieje
    if ! git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        echo "Gałąź $BRANCH_NAME nie istnieje. Tworzę ją..."
        git checkout -b "$BRANCH_NAME"
    else
        git checkout "$BRANCH_NAME"
    fi

    # Tworzenie pustego pliku
    echo "" > "$TMP_DIR/$(basename "$FILE_PATH")"
    git add "$TMP_DIR/$(basename "$FILE_PATH")"
    git commit -m "Wyczyszczenie pliku"
    git push --set-upstream origin "$BRANCH_NAME"

    # Powiadomienie o czyszczeniu pliku
    notify-send "GitClip" "Plik został wyczyszczony na GitHubie."

    # Usuwanie tymczasowego repozytorium
    rm -rf "$TMP_DIR"
    echo "Tymczasowe repozytorium zostało usunięte."
}

# Sprawdzenie opcji i przetwarzanie
setup_git
if [[ "$1" == "-x" ]]; then
    clear_file
else
    decode_and_upload
fi